Перем Результат;
Перем ПутьКФайлуЖурнала;
Перем ОбработкаРазбора;
Перем ДанныеДляОтправки;
Перем РазмерПакетаДляОтправки Экспорт;
Перем НастройкиСоединения Экспорт; 
Перем ЗаголовокИндекса Экспорт;
Перем БылиОшибкиОтправки Экспорт;

#Область ОбработчикиКомандФормы

// Процедура - выполняет чтение и обработку указанного файла
//
// Параметры:
//	Элемент            - ПутьКФайлу          - путь к файлу для чтения
//
Процедура Прочитать(ПутьКФайлу) Экспорт
	
	БылиОшибкиОтправки = Ложь;
	
	ПутьКФайлуЖурнала = ПутьКФайлу;
	
	ОбработкаЧтения = ПолучитьВнешнююОбработкуПоИмени("ктв_ЧтениеСкобкофайла");
	
	ОбработкаЧтения.ДобавитьПравилоОбработки(1, ЭтотОбъект);
	
	ОбработкаЧтения.ПрочитатьСкобкоФайл(ПутьКФайлу);
	
КонецПроцедуры // Прочитать()

// Процедура - выполняет чтение и обработку файлов в указанном каталоге
//
// Параметры:
//	ПутьККаталогу  - Строка        - путь к каталогу для чтения
//
Процедура ПрочитатьКаталог(ПутьККаталогу) Экспорт
	
	БылиОшибкиОтправки = Ложь;
	
	ОбработкаЧтения = ПолучитьВнешнююОбработкуПоИмени("ктв_ЧтениеСкобкофайла");
	
	ОбработкаЧтения.ДобавитьПравилоОбработки(1, ЭтотОбъект);
	
	ПозицияЧтения = ПолучитьНачальнуюПозициюЧтения(ПутьККаталогу);
	
	Файлы = НайтиФайлы(ПутьККаталогу, "*.lgp", Ложь);
	
	СписокФайлов = Новый СписокЗначений();
	
	Для Каждого ТекФайл Из Файлы Цикл
		СписокФайлов.Добавить(ТекФайл, ТекФайл.ИмяБезРасширения);
	КонецЦикла;
	
	СписокФайлов.СортироватьПоПредставлению();
	
	ПропуститьФайл = Истина;
	
	Для Каждого ТекЭлемент Из СписокФайлов Цикл
		
		Если ТекЭлемент.Представление = ПозицияЧтения.ИмяФайла ИЛИ ПустаяСтрока(ПозицияЧтения.ИмяФайла) Тогда
			ПропуститьФайл = Ложь;
		КонецЕсли;
		
		Если ПропуститьФайл Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТекЭлемент.Представление = ПозицияЧтения.ИмяФайла Тогда
			НачальнаяСтрока = ПозицияЧтения.НомерСтроки;
		Иначе
			НачальнаяСтрока = 0;
		КонецЕсли;
		
		ПутьКФайлуЖурнала = ТекЭлемент.Значение.ПолноеИмя;
		
		ОбработкаЧтения.ПрочитатьСкобкоФайл(ПутьКФайлуЖурнала, НачальнаяСтрока);
	
		ОтправитьДанные();
		
		Если НЕ БылиОшибкиОтправки Тогда
			СохранитьНачальнуюПозициюЧтения(ПутьККаталогу, ТекЭлемент.Представление, НачальнаяСтрока);
		КонецЕсли;
			
	КонецЦикла;
	
КонецПроцедуры // ПрочитатьКаталог()

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Функция - возвращает результат, накопленный обработкой
// 
// Параметры:
//  ЗавершениеОбработки      - Булево       Истина - выполнить действия при завершении обработки
//
// Возвращаемое значение:
//  Произвольный -  результат, накопленный обработкой
//
Функция ПолучитьРезультат(ЗавершениеОбработки = Ложь) Экспорт
	
	Если ЗавершениеОбработки Тогда
		ОтправитьДанные();
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьРезультат()

// Функция - преобразует переданный элемент из общего формата разбора скобкофайла в требуемый формат
//
// Параметры:
//	Элемент         - Структура       проверяемый элемент
//		*Родитель            - Структура                 - ссылка на элемент-родитель
//		*Уровень             - Число                     - уровень иерархии элемента
//		*Индекс              - Число                     - индекс элемента в массиве значений родителя
//		*НомераСтрок         - Соответсвие(Число)        - массив номеров строк из которых был прочитан элемент и его дочерние элементы
//		*НачСтрока           - Число                     - номер первой строки из которой был прочитан элемент и его дочерние элементы
//		*КонСтрока           - Число                     - номер последней строки из которой был прочитан элемент и его дочерние элементы
//		*Значения            - Массив(Структура)         - массив дочерних элементов
//
// Возвращаемое значение:
//	Структура      - результат преобразования
//
Функция РазобратьЭлемент(Элемент) Экспорт
	
	Если ОбработкаРазбора = Неопределено Тогда
		ОбработкаРазбора = ПолучитьВнешнююОбработкуПоИмени("ктв_ЧтениеЖР");
		ОбработкаРазбора.ПутькФайлуЖурнала = ПутьКФайлуЖурнала;
	КонецЕсли;
	
	Запись = ОбработкаРазбора.РазобратьЭлемент(Элемент);
	
	Возврат Запись;

КонецФункции // РазобратьЭлемент()

// Процедура - проверяет, что элемент является записью журнала регистрации,
// добавляет его в массив записей и отправляет пакет записей в Elastic
//
// Параметры:
//	Элемент         - Структура                     - проверяемый элемент
//		*Родитель            - Структура                 - ссылка на элемент-родитель
//		*Уровень             - Число                     - уровень иерархии элемента
//		*Индекс              - Число                     - индекс элемента в массиве значений родителя
//		*НомераСтрок         - Соответсвие(Число)        - массив номеров строк из которых был прочитан элемент и его дочерние элементы
//		*НачСтрока           - Число                     - номер первой строки из которой был прочитан элемент и его дочерние элементы
//		*КонСтрока           - Число                     - номер последней строки из которой был прочитан элемент и его дочерние элементы
//		*Значения            - Массив(Структура)         - массив дочерних элементов
//
Процедура ДобавитьЗапись(Элемент) Экспорт
	
	Если НЕ Элемент.Уровень = 1 Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ Элемент.Родитель.Индекс = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Запись = РазобратьЭлемент(Элемент);
	
	Если НЕ ТипЗнч(ДанныеДляОтправки) = Тип("Массив") Тогда
		ДанныеДляОтправки = Новый Массив();
	КонецЕсли;
	
	ДанныеДляОтправки.Добавить(Запись);
	
	Если ДанныеДляОтправки.Количество() >= РазмерПакетаДляОтправки Тогда
		ОтправитьДанные();
		Если НЕ БылиОшибкиОтправки Тогда
			СохранитьНачальнуюПозициюЧтения(КаталогФайла(ПутьКФайлуЖурнала), Запись.ИмяФайла, Элемент.КонСтрока + 1);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры // ДобавитьЗапись()

// Функция - проверяет, что элемент является записью журнала регистрации
// и проверяет необходимость удаления элемента
//
// Параметры:
//	Элемент                  - Структура          - проверяемый элемент (см. НужноУдалитьЭлемент)
//		*Родитель            - Структура                 - ссылка на элемент-родитель
//		*Уровень             - Число                     - уровень иерархии элемента
//		*Индекс              - Число                     - индекс элемента в массиве значений родителя
//		*НомераСтрок         - Соответсвие(Число)        - массив номеров строк из которых был прочитан элемент и его дочерние элементы
//		*НачСтрока           - Число                     - номер первой строки из которой был прочитан элемент и его дочерние элементы
//		*КонСтрока           - Число                     - номер последней строки из которой был прочитан элемент и его дочерние элементы
//		*Значения            - Массив(Структура)         - массив дочерних элементов
//
// Возвращаемое значение:
//   Булево - Истина - элемент нужно удалить после обработки
//
Функция НужноУдалитьЭлемент(Элемент) Экспорт
	
	Если НЕ Элемент.Уровень = 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // НужноУдалитьЭлемент()

#КонецОбласти

#Область ОтправкаДанныхВЭластик

// Функция - Получить соединение
//
// Параметры:
// 	СтруктураНастроек						- Структура			- Структура настроек подключения к http-сервису, в т.ч.:
//		Сервис_Сервер							- Строка			- Адрес сервера http-сервиса
//		Сервис_АдресРесурса						- Строка			- Адрес ресурса http
//		Сервис_Пользователь						- Строка			- Имя пользователя сервиса
//		Сервис_Пароль							- Строка			- Пароль пользователя сервиса
//		УстановленноеСоединение                 - WebПрокси		    - Полученный ранее объект соединения с web-сервисом для повторного использования
//		УстановленноеСоединение_Использование	- Булево			- Флаг необходимости повторного использования объекта соединения с web-сервисом 
// 
// Возвращаемое значение:
//		HTTPСоединение		- Установленное соединение с http-сервисом
//
Функция ПолучитьСоединение(СтруктураНастроек) Экспорт
	
	Соединение = Неопределено;
	
	СоздаватьПодключение = Ложь;
	
	Если СтруктураНастроек.УстановленноеСоединение_Использование Тогда
		СоздаватьПодключение = НЕ (ТипЗнч(СтруктураНастроек.УстановленноеСоединение) = Тип("HTTPСоединение"));
	Иначе
		СоздаватьПодключение = Истина;
	КонецЕсли;
	
	Если СоздаватьПодключение Тогда
		
		//Подключаем http-сервис указанный в настройках подключения к базе
		Попытка
			Соединение = Новый HTTPСоединение(СтруктураНастроек.Сервис_Сервер, , СтруктураНастроек.Сервис_Пользователь, СтруктураНастроек.Сервис_Пароль);
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ВызватьИсключение СтруктураНастроек.Сервис_Сервер + ": " + ТекстОшибки;
		КонецПопытки;
		
		Если СтруктураНастроек.УстановленноеСоединение_Использование Тогда
			СтруктураНастроек.Вставить("УстановленноеСоединение", Соединение);
		КонецЕсли;
			
	Иначе
		Соединение = СтруктураНастроек.УстановленноеСоединение;
	КонецЕсли;
	
	Возврат Соединение;
	
КонецФункции // ПолучитьСоединение()

// Процедура - выполняет отправку данных на сервер elastic
//
// Возвращаемое значение:
//   Структура - словари данных журнала регистрации
//
Процедура ОтправитьДанные(ОчиститьДанныеПослеОтправки = Истина)
	
	Если НЕ ТипЗнч(ДанныеДляОтправки) = Тип("Массив") Тогда
		Возврат;
	КонецЕсли;
	
	Если ДанныеДляОтправки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДанныеОтвета = "";
	ТекстОшибки = "";
	СтрокаЗапроса = "/_bulk?pretty";
	СтрокиДляОтправки = ПолучитьСтрокиДляОтправки(ДанныеДляОтправки);
	
	Соединение = ПолучитьСоединение(НастройкиСоединения);
	
	РезультатОбработки = ПолучитьРезультатОбработкиХТТПСервиса(Соединение,
	                                                           СтрокаЗапроса,
															   СтрокиДляОтправки,
															   ДанныеОтвета,
															   ТекстОшибки);
	
	Если НЕ ТипЗнч(Результат) = Тип("Массив") Тогда
		Результат = Новый Массив();
	КонецЕсли;
	
	ОписаниеРезультата = Новый Структура("Данные, Строки, Обработано, Ответ, ТекстОшибки",
	                                     ДанныеДляОтправки,
	                                     СтрокиДляОтправки,
										 РезультатОбработки,
										 ДанныеОтвета,
										 ТекстОшибки);
	Результат.Добавить(ОписаниеРезультата);
	
	Если НЕ РезультатОбработки Тогда
		БылиОшибкиОтправки = Истина;
	КонецЕсли;
	
	Если ОчиститьДанныеПослеОтправки Тогда
		ДанныеДляОтправки = Новый Массив();
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьСтрокиДляОтправки(ЗаписиЖурнала)
	
	МассивСтрокДляОтправки = Новый Массив();
	
	Для Каждого ТекЗапись Из ЗаписиЖурнала Цикл
		
		СтруктураЗаголовка = Новый Структура("index", Новый Структура());
		
		СтруктураЗаголовка.index.Вставить("_index", ЗаголовокИндекса + "_" + Формат(ТекЗапись.Время, "ДФ=ггггММдд"));
		СтруктураЗаголовка.index.Вставить("_type" , "ЖР");
		СтруктураЗаголовка.index.Вставить("_id"   , ТекЗапись.ИмяФайла + "_" + Формат(ТекЗапись.НомерСтроки, "ЧН=; ЧГ="));
		
		СтрокаДляОтправки = ПреобразоватьЗаписьВJSON(СтруктураЗаголовка);
		СтрокаДляОтправки = СтрЗаменить(СтрокаДляОтправки, Символы.ПС, "");
		СтрокаДляОтправки = СтрЗаменить(СтрокаДляОтправки, Символы.ВК, "");
		МассивСтрокДляОтправки.Добавить(СтрокаДляОтправки);
		
		СтрокаДляОтправки = ПреобразоватьЗаписьВJSON(ТекЗапись);
		СтрокаДляОтправки = СтрЗаменить(СтрокаДляОтправки, Символы.ПС, "");
		СтрокаДляОтправки = СтрЗаменить(СтрокаДляОтправки, Символы.ВК, "");
		МассивСтрокДляОтправки.Добавить(СтрокаДляОтправки);
		
	КонецЦикла;
	
	СтрокаДляОтправки = СтрСоединить(МассивСтрокДляОтправки, Символы.ПС);
	СтрокаДляОтправки = СтрЗаменить(СтрокаДляОтправки, Символы.ВК, "") + Символы.ПС;
	
	Возврат СтрокаДляОтправки;
	
КонецФункции // ПолучитьСтрокиДляОтправки()

Функция ПреобразоватьЗаписьВJSON(ЗаписьЖурнала)
	
	Запись = Новый ЗаписьJSON();
	Запись.УстановитьСтроку();
	
	НастройкиСериализации = Новый НастройкиСериализацииJSON();
	НастройкиСериализации.ВариантЗаписиДаты      = ВариантЗаписиДатыJSON.УниверсальнаяДата;
	НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.ISO;
	
	Попытка
		ЗаписатьJSON(Запись, ЗаписьЖурнала, НастройкиСериализации);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат "{}";
	КонецПопытки;
	
	Возврат Запись.Закрыть();
	
КонецФункции // ПреобразоватьЗаписьВJSON()
	
Функция ПолучитьРезультатОбработкиХТТПСервиса(Соединение, СтрокаЗапроса, ПараметрыЗапросаДляОтправки = "{}", ДанныеОтвета = Неопределено, ТекстОшибки = "") Экспорт
	
	ЗапросКСервису = Новый HTTPЗапрос(СтрокаЗапроса);
	ЗапросКСервису.Заголовки.Вставить("Content-Type", "application/x-ndjson");
	ЗапросКСервису.УстановитьТелоИзСтроки(ПараметрыЗапросаДляОтправки);
		
	ТекстОтвета = "";
		
	Попытка
		ОтветСервиса = Соединение.ОтправитьДляОбработки(ЗапросКСервису);
		ТекстОтвета = ОтветСервиса.ПолучитьТелоКакСтроку();
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
		
	Если НЕ Лев(ОтветСервиса.КодСостояния, 1) = "2" Тогда
		ТекстОшибки = СокрЛП(ОтветСервиса.КодСостояния) + ": <" + ТекстОтвета + ">";
		Возврат Ложь;
	КонецЕсли;
	
	Если ПустаяСтрока(ТекстОтвета) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ЧтениеДанныхОтвета = Новый ЧтениеJSON();
	ЧтениеДанныхОтвета.УстановитьСтроку(ТекстОтвета);
		
	СвойстваСоЗначениемДата = Новый Массив();
	//СвойстваСоЗначениемДата.Добавить("Дата");
		
	Попытка
		ДанныеОтвета = ПрочитатьJSON(ЧтениеДанныхОтвета, Ложь, СвойстваСоЗначениемДата, ФорматДатыJSON.ISO);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции //ПолучитьРезультатОбработкиХТТПСервиса()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция - ищет внешнюю обработку по указанному имени рядом с текущей и подключает ее
// возвращает объект подключенной обработки
//
// Параметры:
//  ИмяОбработки         - Строка        - имя внешней обработки
// 
// Возвращаемое значение:
//  ВнешняяОбработкаОбъект        - внешняя обработка
// 
Функция ПолучитьВнешнююОбработкуПоИмени(ИмяОбработки)
	
	ФайлЭтойОбработки = Новый Файл(ЭтотОбъект.ИспользуемоеИмяФайла);
	
	ПутьКОбработке = ФайлЭтойОбработки.Путь + ИмяОбработки + ФайлЭтойОбработки.Расширение;
	
	Возврат ВнешниеОбработки.Создать(ПутьКОбработке, Ложь);
	
КонецФункции // ПолучитьВнешнююОбработкуПоИмени()

// Функция - возвращает словари данных для чтения журнала регистрации
//
// Возвращаемое значение:
//   Структура - словари данных журнала регистрации
//
Функция ПолучитьСловариДанныхЖР()
	
	ФайлЖурнала = Новый Файл(ПутьКФайлуЖурнала);
	
	ПутьКФайлуСловарей = ФайлЖурнала.Путь + "1Cv8.lgf";
	
	Попытка
		ОбработкаЧтенияСловарей = ПолучитьВнешнююОбработкуПоИмени("ктв_ЧтениеСловаряЖР");
		
		ОбработкаЧтенияСловарей.Прочитать(ПутьКФайлуСловарей);
		
		РезультатЧтенияСловарей = ОбработкаЧтенияСловарей.ПолучитьРезультат(Истина);
	Исключение
		Возврат Новый Структура();
	КонецПопытки;
	
	Если РезультатЧтенияСловарей.Количество() = 0 Тогда
		Возврат Новый Структура();
	Иначе
		Возврат РезультатЧтенияСловарей;
	КонецЕсли; 
	
КонецФункции // ПолучитьСловариДанныхЖР()

// Функция - Определяет каталог файла
//
// Параметры:
//  ПутьКФайлу	 - Строка - путь к проверяемому файлу
// 
// Возвращаемое значение:
//   Строка - каталог файла
//
Функция КаталогФайла(ПутьКФайлу)
	
	ВремФайл = Новый Файл(ПутьКФайлу);
	
	Возврат Сред(ВремФайл.Путь, 1, СтрДлина(ВремФайл.Путь) - 1);
	
КонецФункции // КаталогФайла()

// Функция - получает информацию о начальной позиции чтения данных
//
// Параметры:
//  ПутьККаталогу	 - Строка - путь к каталогу журнала регистрации
// 
// Возвращаемое значение:
//   Структура - описание начальной позиции чтения
//       ИмяФайла     - Строка - имя первого файла
//       НомерСтроки  - Число  - номер начальной строки в файле
//
Функция ПолучитьНачальнуюПозициюЧтения(ПутьККаталогу) Экспорт
	
	ВремФайл = Новый Файл(ПутьККаталогу + "\readpoint.lg");
	
	Результат = Новый Структура("ИмяФайла, НомерСтроки", "", 1);
	
	Если НЕ ВремФайл.Существует() Тогда
		Возврат Результат;
	КонецЕсли;
	
	ВремТекст = Новый ТекстовыйДокумент();
	ВремТекст.Прочитать(ВремФайл.ПолноеИмя);
		
	СтрокаПозиции = ВремТекст.ПолучитьСтроку(1);
		
	Если ПустаяСтрока(СтрокаПозиции) Тогда
		Возврат Результат;
	КонецЕсли;
	
	МассивПозиции = СтрРазделить(СтрокаПозиции, ":");
	
	Если МассивПозиции.Количество() < 2 Тогда 
		Возврат Результат;
	КонецЕсли;
	
	Результат.ИмяФайла    = МассивПозиции[0];
	Результат.НомерСтроки = Число(МассивПозиции[1]);
	
	Возврат Результат;
	
КонецФункции // ПолучитьНачальнуюПозициюЧтения()

// Процедура - сохраняет в файл информацию о начальной позиции для будущего чтения
//
// Параметры:
//  ПутьККаталогу	 - Строка - путь к каталогу журнала регистрации
//  ИмяФайла         - Строка - имя первого файла
//  НомерСтроки      - Число  - номер начальной строки в файле
// 
Процедура СохранитьНачальнуюПозициюЧтения(ПутьККаталогу, ИмяФайла, НомерСтроки)
	
	ВремТекст = Новый ТекстовыйДокумент();
	ВремТекст.ДобавитьСтроку(ИмяФайла + ":" + Формат(НомерСтроки, "ЧН=; ЧГ=0"));
	ВремТекст.Записать(ПутьККаталогу + "\readpoint.lg");
	
КонецПроцедуры // СохранитьНачальнуюПозициюЧтения()

// Функция - удаляет начальные, конечные и экранированные кавычки из строки
//
// Параметры:
//  ПарамСтрока	 - Строка - строка для обработки
// 
// Возвращаемое значение:
//   Строка - результирующая строка
//
Функция ОбработатьКавычкиВСтроке(Знач ПарамСтрока)
	
	ПарамСтрока = СтрЗаменить(ПарамСтрока, """""", """");
	
	Если Лев(ПарамСтрока, 1) = """" Тогда
		ПарамСтрока = Сред(ПарамСтрока, 2);
	КонецЕсли;
	
	Если Прав(ПарамСтрока, 1) = """" Тогда
		ПарамСтрока = Сред(ПарамСтрока, 1, СтрДлина(ПарамСтрока) - 1);
	КонецЕсли;
	
	Возврат СокрЛП(ПарамСтрока);
	
КонецФункции // ОбработатьКавычкиВСтроке()

#КонецОбласти
